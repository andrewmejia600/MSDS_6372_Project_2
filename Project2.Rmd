---
title: "DS6372_Project2"
author: "AndrewMejia"     
date: "3/15/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.


```{r}

library(ggplot2)
library(GGally)
library(dplyr)
library(caret)
library(plotly)
library(ResourceSelection)
library(car)
library(ROCR)
library(MASS)
library(stringr)
library(glmnet)
library(bestglm)


Bank_mrkt_data  = read.csv(file.choose(),header = TRUE, sep = ';')

#Looking for complete records
Bank_mrkt_data %>% filter(complete.cases(Bank_mrkt_data))

#Looking for incomplete records 
Bank_mrkt_data %>% filter(!complete.cases(Bank_mrkt_data))

summary(Bank_mrkt_data)

#unknown records 

dim(Bank_mrkt_data %>% filter(grepl("unknown", Bank_mrkt_data$education)==TRUE))[1]
dim(Bank_mrkt_data %>% filter(grepl("unknown", Bank_mrkt_data$job)==TRUE))[1]

#filtering out unknown responses  for unkowns 

Bank_mrkt_data = Bank_mrkt_data %>% filter((Bank_mrkt_data$education != "unknown") & 
                                             (Bank_mrkt_data$job != "unknown") & 
                                             (Bank_mrkt_data$marital != "unkown") & 
                                             (Bank_mrkt_data$default != "unkown") &
                                             (Bank_mrkt_data$housing != "unkown") &
                                             (Bank_mrkt_data$loan != "unkown") &
                                             (Bank_mrkt_data$contact != "unkown") &
                                             (Bank_mrkt_data$loan != "unkown"))




plot(Bank_mrkt_data[,1:3], col = Bank_mrkt_data$y)
plot(Bank_mrkt_data[,4:7], col = Bank_mrkt_data$y)
plot(Bank_mrkt_data[,8:11], col = Bank_mrkt_data$y)
plot(Bank_mrkt_data[,12:15], col = Bank_mrkt_data$y)
plot(Bank_mrkt_data[,16:20], col = Bank_mrkt_data$y)

#need to make scatter plots based on differences in response variables of colors see HW for LDA     
#We can see there is a disporationate amount of nos to yes records
ggpairs(Bank_mrkt_data[,c(21, 1:3)], ggplot2::aes(colour=y))

ggpairs(Bank_mrkt_data[,c(21, 4:7)],  ggplot2::aes(colour=y))

ggpairs(Bank_mrkt_data[,c(21, 8:11)],  ggplot2::aes(colour=y))

ggpairs(Bank_mrkt_data[,c(21, 12:15)],  ggplot2::aes(colour=y))

ggpairs(Bank_mrkt_data[,c(21, 16:20)],  ggplot2::aes(colour=y))




Bank_mrkt_data %>% ggplot(aes(x = marital, y = age , color = y)) + geom_point()

Bank_mrkt_data %>% ggplot(aes(x = marital, y = age , color = y)) + geom_boxplot()

Bank_mrkt_data %>% ggplot(aes(x = job, y = age , color = y)) + geom_boxplot()

Bank_mrkt_data %>% ggplot(aes(x = marital, y = age , color = y)) + geom_col()


#Note Duration can only be used as a sanity check 



boxplot(Bank_mrkt_data$duration ~ Bank_mrkt_data$y, data = Bank_mrkt_data)


#see a limited seperation of duration and month 
Bank_mrkt_data %>% ggplot(aes(x = duration, y = month , color = y)) + geom_point()

Bank_mrkt_data %>% ggplot(aes(x = duration, y = month , color = y)) + geom_point()


#See a clear seperation between duration and age 
Bank_mrkt_data %>% ggplot(aes(x = age, y = duration , color = y)) + geom_point() + geom_jitter()

# see a clear seperation between duration and campaingn
Bank_mrkt_data %>% ggplot(aes(x = duration, y = campaign , color = y)) + geom_point() + geom_jitter()

#Bank_mrkt_data %>% ggplot(aes(x = previous, y = campaign , color = y)) + geom_point()

#Star to see a clear seperation between nr. employed and cons.price.idx   
Bank_mrkt_data %>% ggplot(aes(x = nr.employed, y = cons.price.idx , color = y)) + geom_boxplot()

Bank_mrkt_data %>% ggplot(aes(x = job, y = cons.price.idx , color = y)) + geom_boxplot()

Bank_mrkt_data %>% ggplot(aes(x = nr.employed, y = cons.conf.idx , color = y)) + geom_boxplot()

Bank_mrkt_data %>% ggplot(aes(x = euribor3m, y = emp.var.rate, color = y)) + geom_point() + geom_jitter()

Bank_mrkt_data %>% ggplot(aes(x = nr.employed, y = emp.var.rate, color = y)) + geom_point() + geom_jitter()

Bank_mrkt_data %>% ggplot(aes(x =euribor3m , y = nr.employed, color = y)) + geom_point() + geom_jitter()


#Looking for complex interactions marital and age seem to have some interaction 

Bank_mrkt_data %>% ggplot(aes(x = education, y = age , color = y)) + geom_boxplot()

Bank_mrkt_data %>% ggplot(aes(x = job, y = age , color = y)) + geom_boxplot()

Bank_mrkt_data %>% ggplot(aes(x = marital, y = age , color = y)) + geom_boxplot()


Bank_mrkt_data %>% ggplot(aes(x = contact, y = duration , color = y)) + geom_boxplot()

#3d Graphs of duration 

fig = plot_ly(Bank_mrkt_data, x = Bank_mrkt_data$duration, y = Bank_mrkt_data$age, z = Bank_mrkt_data$y, color = Bank_mrkt_data$y, colors = c('#BF382A', '#0C4B8E'))
fig = fig %>% add_markers()
fig = fig %>% layout(scene = list(xaxis = list(title = 'Duration'),
                     yaxis = list(title = 'Age'),
                     zaxis = list(title = 'Outcome')))

fig
  


fig2 = plot_ly(Bank_mrkt_data, x = Bank_mrkt_data$duration, y = Bank_mrkt_data$campaign, z = Bank_mrkt_data$y, color = Bank_mrkt_data$y, colors = c('#BF382A', '#0C4B8E'))
fig2 = fig2 %>% add_markers()
fig2 = fig2 %>% layout(scene = list(xaxis = list(title = 'Duration'),
                     yaxis = list(title = 'Campaign'),
                     zaxis = list(title = 'Outcome')))

fig2







fig3 = plot_ly(Bank_mrkt_data, x = Bank_mrkt_data$euribor3m, y = Bank_mrkt_data$emp.var.rate, z = Bank_mrkt_data$y, color = Bank_mrkt_data$y, colors = c('#BF382A', '#0C4B8E'))
fig3 = fig3 %>% add_markers()
fig3 = fig3 %>% layout(scene = list(xaxis = list(title = 'Euribor3m'),
                     yaxis = list(title = 'Emp.Var.Rate'),
                     zaxis = list(title = 'Outcome')))

fig3



fig4 = plot_ly(Bank_mrkt_data, x = Bank_mrkt_data$nr.employed, y = Bank_mrkt_data$emp.var.rate, z = Bank_mrkt_data$y, color = Bank_mrkt_data$y, colors = c('#BF382A', '#0C4B8E'))
fig4 = fig4 %>% add_markers()
fig4 = fig4 %>% layout(scene = list(xaxis = list(title = 'nr.employed'),
                     yaxis = list(title = 'emp.var.rate'),
                     zaxis = list(title = 'Outcome')))

fig4


fig5 = plot_ly(Bank_mrkt_data, x = Bank_mrkt_data$nr.employed, y = Bank_mrkt_data$euribor3m, z = Bank_mrkt_data$y, color = Bank_mrkt_data$y, colors = c('#BF382A', '#0C4B8E'))
fig5 = fig5 %>% add_markers()
fig5 = fig5 %>% layout(scene = list(xaxis = list(title = 'nr.employed'),
                     yaxis = list(title = 'emp.var.rate'),
                     zaxis = list(title = 'Outcome')))

fig5



```

```{r}


#Test Train Splits 

#Down Sampling 
set.seed(1234)
Bank_mrkt_data_dwn_sample = downSample(Bank_mrkt_data[,1:20], Bank_mrkt_data[,21])

#Controling Sampling by modifying the p in the create partition for creating the test train splits from the downsampled data for training. 
set.seed(1234)
Bank_mrkt_data_partition_idx = createDataPartition(Bank_mrkt_data_dwn_sample$Class, p=.5, list = FALSE, times = 1)

Bank_mrkt_data_partition_train = Bank_mrkt_data_dwn_sample[Bank_mrkt_data_partition_idx,]
Bank_mrkt_data_partition_test = Bank_mrkt_data_dwn_sample[-Bank_mrkt_data_partition_idx,]

#Removing Row Number Partitions indices 
row.names(Bank_mrkt_data_partition_train) = NULL
row.names(Bank_mrkt_data_partition_test) = NULL 




colname_vec = str_replace_all(toString(names(Bank_mrkt_data)[1:20]),"\\,", "\\ +")

#lda_analysis = lda(Class ~ age + job + marital + education + default + housing + loan + contact + month + day_of_week + duration + campaign + pdays + previous + poutcome + emp.var.rate + cons.price.idx + cons.conf.idx + euribor3m + nr.employed, data = Bank_mrkt_data_partition_train)

#LDA on continous variables --- Highest Accuracy 

lda_analysis = lda(Class ~ age +  duration + campaign + pdays + previous + emp.var.rate + cons.price.idx + cons.conf.idx + euribor3m + nr.employed, data = Bank_mrkt_data_partition_train)

pred = predict(lda_analysis,newdata=Bank_mrkt_data_partition_test)$class  #Predictions can come in many forms, the class form provides the categorical level of your response.
Truth = Bank_mrkt_data_partition_test$Class
x = table(pred,Truth) # Creating a confusion matrix
x
#Missclassification Error
ME = (x[2,1]+x[1,2])/sum(x)
ME
#Calculating overall accuracy
1-ME

#LDA of highly correlated factors 

lda_analysis = lda(Class ~ emp.var.rate + nr.employed + euribor3m, data = Bank_mrkt_data_partition_train)

pred = predict(lda_analysis,newdata=Bank_mrkt_data_partition_test)$class  #Predictions can come in many forms, the class form provides the categorical level of your response.
Truth = Bank_mrkt_data_partition_test$Class
x = table(pred,Truth) # Creating a confusion matrix
x
#Missclassification Error
ME = (x[2,1]+x[1,2])/sum(x)
ME
#Calculating overall accuracy
1-ME

#LDA of highly varianced correlated factors 

lda_analysis = lda(Class ~ previous + emp.var.rate + cons.price.idx, data = Bank_mrkt_data_partition_train)

pred = predict(lda_analysis,newdata=Bank_mrkt_data_partition_test)$class  #Predictions can come in many forms, the class form provides the categorical level of your response.
Truth = Bank_mrkt_data_partition_test$Class
x = table(pred,Truth) # Creating a confusion matrix
x
#Missclassification Error
ME = (x[2,1]+x[1,2])/sum(x)
ME
#Calculating overall accuracy
1-ME

lda_analysis = lda(Class ~ age +  duration + campaign + pdays + previous + emp.var.rate + cons.price.idx + cons.conf.idx + euribor3m + nr.employed, data = Bank_mrkt_data_partition_train, prior =  c(.89,.11))

pred = predict(lda_analysis,newdata=Bank_mrkt_data_partition_test)$class  #Predictions can come in many forms, the class form provides the categorical level of your response.
Truth = Bank_mrkt_data_partition_test$Class
x = table(pred,Truth) # Creating a confusion matrix
x
#Missclassification Error
ME = (x[2,1]+x[1,2])/sum(x)
ME
#Calculating overall accuracy
1-ME

#PCA outputs for LDA comparison : model does not perform as well as original LDA with highest accuracy of 84% 

lda_analysis = lda(Class ~ age + duration, data = Bank_mrkt_data_partition_train)

pred = predict(lda_analysis,newdata=Bank_mrkt_data_partition_test)$class  #Predictions can come in many forms, the class form provides the categorical level of your response.
Truth = Bank_mrkt_data_partition_test$Class
x = table(pred,Truth) # Creating a confusion matrix
x
#Missclassification Error
ME = (x[2,1]+x[1,2])/sum(x)
ME
#Calculating overall accuracy
1-ME



#qda analysis 
qda_analysis = qda(Class ~ age +  duration + campaign + pdays + previous + emp.var.rate + cons.price.idx + cons.conf.idx + euribor3m + nr.employed, data = Bank_mrkt_data_partition_train)

pred = predict(lda_analysis,newdata=Bank_mrkt_data_partition_test)$class  #Predictions can come in many forms, the class form provides the categorical level of your response.
Truth = Bank_mrkt_data_partition_test$Class
x = table(pred,Truth) # Creating a confusion matrix
x
#Missclassification Error
ME = (x[2,1]+x[1,2])/sum(x)
ME
#Calculating overall accuracy
1-ME


```

PCA Analysis 
```{r}
#Balanced test train split
pairs(Bank_mrkt_data_partition_train[, c(1,11,12,13,14,16,17,18,19,20)], col = Bank_mrkt_data_partition_train$Class)

#Not balanced, only 11% is yes 
pairs(Bank_mrkt_data[, c(1,11,12,13,14,16,17,18,19,20)], col = Bank_mrkt_data$y)

#bank_train_reduced = Bank_mrkt_data_partition_train[, c(1,11,12,13,14,16,17,18,19,20)]

#bank_train_reduced = Bank_mrkt_data_partition_train[, c(1,11,12,20)]

#bank_train_reduced = Bank_mrkt_data_partition_train[, c(1,11,16,18)]


#bank_train_reduced = Bank_mrkt_data[, c(1,12,18)]

#promising 
bank_train_reduced = Bank_mrkt_data[,c(1,11,12,16)]

#Also promising correlated vars 
#bank_train_reduced = Bank_mrkt_data[,c(1,11,16)]

pairs(bank_train_reduced, col = Bank_mrkt_data$y)

pc.result = prcomp(bank_train_reduced,scale.=TRUE)
pc.scores = pc.result$x

pc.result
pairs(pc.scores)


```

```{r}

par(mfrow=c(1,2))
eigenvals<-(pc.result$sdev)^2
plot(1:dim(bank_train_reduced)[2],eigenvals/sum(eigenvals),type="l",main="Scree Plot",ylab="Prop. Var. Explained")
cumulative.prop<-cumsum(eigenvals/sum(eigenvals))
plot(1:dim(bank_train_reduced)[2],cumulative.prop,type="l",main="Cumulative proportion",ylim=c(0,1))


```

```{r}
par(mfrow=c(1,1))

##Minimal PCAs needed to have cumulative explained variance higher than .9

minimal.pca <- which(cumulative.prop>0.9)[1]
minimal.pca
```

Ading the response column to the PCs 
```{r}
pc.scores = data.frame(pc.scores)
#pc.scores$Class = Bank_mrkt_data_partition_train$Class
pc.scores$Class = Bank_mrkt_data$y

ggplot(data = pc.scores, aes(x = PC1, y = PC2 )) + geom_point(aes(col=pc.scores$Class), size = 1, shape = '*') + ggtitle("PCA of Deposits ")

ggplot(data = pc.scores, aes(x = PC2, y = PC3 )) + geom_point(aes(col=pc.scores$Class), size = 1, shape = '*') + ggtitle("PCA of Deposits ")


ggplot(data = pc.scores, aes(x = PC3, y = PC4 )) + geom_point(aes(col=pc.scores$Class), size = 1, shape = '*') + ggtitle("PCA of Deposits ")

```

#Logistic Regression Full list of variables -- HL GOF test pvalue < 2.2e-16 not a good fit 

```{r}


main.logr<-glm(Class ~ age + job + marital + education + default + housing + loan + contact + month + day_of_week + duration + campaign + pdays + previous + poutcome + emp.var.rate + cons.price.idx + cons.conf.idx + euribor3m + nr.employed ,data=Bank_mrkt_data_partition_train ,family=binomial(link='logit') )

summary(main.logr)
exp(cbind("Odds ratio" = coef(main.logr), confint.default(main.logr, level = 0.95)))
#vif(logr)

plot(main.logr, pch = 16)


hoslem.test(main.logr$y, fitted(main.logr), g=10)

pred = predict(main.logr, newdata = Bank_mrkt_data_partition_test, type="response")

Bank_mrkt_data_partition_test['Pred_Out'] = as.factor(ifelse(pred>.50, "Yes", "No"))

Truth = Bank_mrkt_data_partition_test$Class
Predt = Bank_mrkt_data_partition_test$Pred_Out

x = table(Predt, Truth) # Creating a confusion matrix
x
#Missclassification Error
ME = (x[2,1]+x[1,2])/sum(x)
ME
#Calculating overall accuracy
1-ME

```

#The Leverage plot looks better here then compared to original model with all predictors  and HSLM test proves better fitting model --- Possibly start thinking of duration as a categorical variable 
```{r}

logr<-glm(Class ~ age + job + education + contact + campaign + previous ,data=Bank_mrkt_data_partition_train ,family=binomial(link='logit') )

summary(logr)
exp(cbind("Odds ratio" = coef(logr), confint.default(logr, level = 0.95)))
vif(logr)

plot(logr)



hoslem.test(logr$y, fitted(logr), g=10)

pred = predict(logr, newdata = Bank_mrkt_data_partition_test, type="response")

Bank_mrkt_data_partition_test['Pred_Out'] = as.factor(ifelse(pred>.50, "Yes", "No"))

Truth = Bank_mrkt_data_partition_test$Class
Predt = Bank_mrkt_data_partition_test$Pred_Out

x = table(Predt, Truth) # Creating a confusion matrix
x
#Missclassification Error
ME = (x[2,1]+x[1,2])/sum(x)
ME
#Calculating overall accuracy
1-ME



```




#Origianl complex model 
```{r}

main.logr_l = glm(Class ~ age + job + education + contact,data=Bank_mrkt_data_partition_train ,family=binomial(link='logit'))


summary(main.logr_l)
exp(cbind("Odds ratio" = coef(main.logr_l), confint.default(main.logr_l, level = 0.95)))
vif(main.logr_l)

plot(main.logr_l)


hoslem.test(main.logr_l$y, fitted(main.logr_l), g=10)


pred = predict(main.logr_l, newdata = Bank_mrkt_data_partition_test, type="response")

Bank_mrkt_data_partition_test['Pred_Out'] = as.factor(ifelse(pred>.50, "Yes", "No"))

Truth = Bank_mrkt_data_partition_test$Class
Predt = Bank_mrkt_data_partition_test$Pred_Out

x = table(Predt, Truth) # Creating a confusion matrix
x
#Missclassification Error
ME = (x[2,1]+x[1,2])/sum(x)
ME
#Calculating overall accuracy
1-ME

logr.model.complex = glm(Class ~ age + job + education + contact + age:contact + age:education ,data=Bank_mrkt_data_partition_train ,family=binomial(link='logit'))
step(main.logr_l,
     scope = list(upper=logr.model.complex),
     direction="forward",
     test="Chisq",
     data=Bank_mrkt_data_partition_train)
hoslem.test(logr.model.complex$y, fitted(logr.model.complex), g=10)

pred = predict(logr.model.complex, newdata = Bank_mrkt_data_partition_test, type="response")

Bank_mrkt_data_partition_test['Pred_Out'] = as.factor(ifelse(pred>.50, "Yes", "No"))

Truth = Bank_mrkt_data_partition_test$Class
Predt = Bank_mrkt_data_partition_test$Pred_Out

x = table(Predt, Truth) # Creating a confusion matrix
x
#Missclassification Error
ME = (x[2,1]+x[1,2])/sum(x)
ME
#Calculating overall accuracy
1-ME


```

#looks more promising less outliers with leverage and passes GOF test, looking at earlier box plot of marital and age and look at AIC 
```{r}

main.logr_l_2 = glm(Class ~ age + job + education + contact + marital,data=Bank_mrkt_data_partition_train ,family=binomial(link='logit'))

plot(main.logr_l_2)

pred = predict(main.logr_l_2, newdata = Bank_mrkt_data_partition_test, type="response")

Bank_mrkt_data_partition_test['Pred_Out'] = as.factor(ifelse(pred>.50, "Yes", "No"))

Truth = Bank_mrkt_data_partition_test$Class
Predt = Bank_mrkt_data_partition_test$Pred_Out

x = table(Predt, Truth) # Creating a confusion matrix
x
#Missclassification Error
ME = (x[2,1]+x[1,2])/sum(x)
ME
#Calculating overall accuracy
1-ME



logr.model.complex = glm(Class ~ age + job + education + contact + marital + age:marital ,data=Bank_mrkt_data_partition_train ,family=binomial(link='logit'))
step(main.logr_l_2,
     scope = list(upper=logr.model.complex),
     direction="forward",
     test="Chisq",
     data=Bank_mrkt_data_partition_train)
hoslem.test(logr.model.complex$y, fitted(logr.model.complex), g=10)

plot(logr.model.complex)

pred = predict(logr.model.complex, newdata = Bank_mrkt_data_partition_test, type="response")

Bank_mrkt_data_partition_test['Pred_Out'] = as.factor(ifelse(pred>.50, "Yes", "No"))

Truth = Bank_mrkt_data_partition_test$Class
Predt = Bank_mrkt_data_partition_test$Pred_Out

x = table(Predt, Truth) # Creating a confusion matrix
x
#Missclassification Error
ME = (x[2,1]+x[1,2])/sum(x)
ME
#Calculating overall accuracy
1-ME


```
#ROC Curves need to be made into GLMNET not ready yet 
```{r}

Bank_mrkt_data_partition_formula = as.formula(Class ~ age + job + education + contact + marital)
Bank_mrkt_data_partition_train_mat.x = model.matrix(Bank_mrkt_data_partition_formula, Bank_mrkt_data_partition_train)
Bank_mrkt_data_partition_train_mat.y = as.matrix(Bank_mrkt_data_partition_train[,21], ncol=1) 

Bank_mrkt_data_partition_test_mat.x = model.matrix(Bank_mrkt_data_partition_formula, Bank_mrkt_data_partition_test)
Bank_mrkt_data_partition_test_mat.y = as.matrix(Bank_mrkt_data_partition_test[,21], ncol=1) 


log_glmnet = glmnet(Bank_mrkt_data_partition_train_mat.x, Bank_mrkt_data_partition_train_mat.y, family = "binomial")

plot(log_glmnet)

coef(log_glmnet)

cvfit =  cv.glmnet(Bank_mrkt_data_partition_train_mat.x, Bank_mrkt_data_partition_train_mat.y, family = "binomial", type.measure = "class", nlambda = 1000)

plot(cvfit)
coef(cvfit, s = "lambda.min")


fit.pred = predict(cvfit, newx =  Bank_mrkt_data_partition_train_mat.x, type = "response")

pred  = prediction(fit.pred[,1], Bank_mrkt_data_partition_train_mat.y)
roc.perf = performance(pred, measure = "tpr", x.measure = "fpr")
auc.train = performance(pred, measure = "auc")
auc.train =  auc.train@y.values

#Plot ROC
plot(roc.perf)
abline(a=0, b= 1) #Ref line indicating poor performance
text(x = .40, y = .6,paste("AUC = ", round(auc.train[[1]],3), sep = ""))



fit.pred.test = predict(cvfit, newx =  Bank_mrkt_data_partition_test_mat.x, type = "response")

pred.test  = prediction(fit.pred.test[,1], Bank_mrkt_data_partition_test_mat.y)
roc.perf = performance(pred.test, measure = "tpr", x.measure = "fpr")
auc.train = performance(pred.test, measure = "auc")
auc.train =  auc.train@y.values

#Plot ROC
plot(roc.perf)
abline(a=0, b= 1) #Ref line indicating poor performance
text(x = .40, y = .6,paste("AUC = ", round(auc.train[[1]],3), sep = ""))

```



